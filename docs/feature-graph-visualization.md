# 대용량 데이터 시각화를 위한 그래프 기능 구현 계획

## 1. 개요

수십 GB에 달하는 대용량 CSV 파일의 데이터를 사용자가 원활하게 탐색하고 분석할 수 있도록, 반응형 그래프 시각화 기능을 구현하는 것을 목표로 한다. 브라우저의 성능 한계를 고려하여, 서버 사이드 기술을 적극적으로 활용해 최적의 사용자 경험을 제공한다.

## 2. 핵심 요구사항

- **대용량 데이터 처리:** 수천만 건 이상의 행(Row)을 가진 데이터를 브라우저 다운 없이 시각화할 수 있어야 한다.
- **인터랙티브 탐색:** 사용자는 차트의 특정 영역을 확대(Zoom)하거나, 좌우로 이동(Pan)하며 데이터를 탐색할 수 있어야 한다.
- **빠른 응답성:** 사용자의 모든 인터랙션(확대, 이동 등)에 대해 시스템은 지연 없이 즉각적으로 차트를 업데이트해야 한다.
- **다양한 차트 지원:** 기본적인 선(Line), 막대(Bar) 차트 및 산점도(Scatter Plot)를 지원하여 데이터 특성에 맞는 분석을 가능하게 한다.

## 3. 기술적 접근 방식

브라우저에 모든 원본 데이터를 전송하는 것은 불가능하므로, 백엔드(DuckDB)의 빠른 처리 능력을 활용한 다음 전략을 사용한다.

### 3.1. 서버 사이드 집계 (Server-Side Aggregation)

- **개념:** 화면에 표시할 수 있는 픽셀의 수는 한정되어 있으므로, 원본 데이터를 그대로 보내는 대신 백엔드에서 현재 차트의 해상도에 맞춰 데이터를 의미 있는 단위로 요약(집계)하여 전달한다.
- **구현:** DuckDB의 `GROUP BY` 기능을 사용하여 데이터를 특정 구간(Bin)으로 나눈다.
  - **시계열 데이터:** `time_bucket()` 함수를 사용하여 시간 단위(예: 1분, 1시간, 1일)로 그룹화하고, 각 그룹의 평균, 최대/최소값 등을 계산한다.
  - **범주형 데이터:** `GROUP BY`로 카테고리별 데이터 개수(COUNT)나 합계(SUM)를 계산한다.

### 3.2. 동적 로딩 (Zoom & Pan)

- **개념:** 사용자의 인터랙션에 따라 보이는 데이터의 범위를 동적으로 변경하고, 해당 범위에 맞는 집계 데이터를 백엔드에 실시간으로 요청하여 차트를 업데이트한다.
- **구현 워크플로:**
  1. 사용자가 차트를 확대하거나 이동(Pan)한다.
  2. 프론트엔드는 변경된 데이터의 범위(예: 시작/종료 시간)를 감지한다.
  3. 이 범위를 파라미터로 백엔드 API(`_**/api/v1/chart-data**_`)를 호출한다.
  4. 백엔드는 해당 범위와 확대 수준에 맞춰 데이터를 다시 집계하여 응답한다.
  5. 프론트엔드는 새로 받은 데이터로 차트를 다시 그린다.

### 3.3. 데이터 샘플링 (Data Sampling)

- **개념:** 데이터의 전체적인 분포를 파악해야 하는 산점도(Scatter Plot) 같은 경우, 집계 대신 원본 데이터의 일부를 무작위로 추출하여 사용한다.
- **구현:** DuckDB의 `USING SAMPLE` 절을 사용하여 지정된 수의 데이터를 효율적으로 샘플링하여 프론트엔드에 전달한다.

### 3.4. 결측치 보간 (Missing Value Interpolation)

- **개념:** 시계열 데이터에서 누락된 값(결측치)은 차트의 연속성을 해치고 분석을 어렵게 만든다. 보간은 이러한 빈틈을 추정된 값으로 채워넣어 데이터의 연속성을 확보하는 기능이다.
- **구현:** DuckDB의 시계열 처리 기능인 `GAPFILL`을 사용하여 비어있는 시간 간격을 채우고, `LOCF`(Last Observation Carried Forward) 등의 함수로 값을 보간한다.
- **지원할 보간 방법:**
  - **선형(Linear):** 두 개의 알려진 점 사이를 직선으로 연결하여 값을 추정한다. (DuckDB에서 직접 지원하지 않으므로, Polars 라이브러리 연동 또는 클라이언트 사이드 계산 필요)
  - **이전 값으로 채우기(Forward Fill):** 가장 최근의 유효한 관측값으로 결측치를 채운다. (DuckDB의 `LOCF` 함수와 유사)
  - **보간 안 함(None):** 데이터를 있는 그대로 사용한다. (기본값)

## 4. 구현 계획

### 4.1. 백엔드 (FastAPI)

1.  **API 엔드포인트 신설 (`api/routes.py`)**
    - `POST /api/v1/chart-data`: 차트 데이터 요청을 처리하는 엔드포인트를 추가한다.
2.  **API 스키마 정의 (`api/schemas.py`)**
    - `ChartDataRequest`: 요청 시 필요한 정보에 `interpolation_method: Optional[str] = 'none'` (보간 방법)을 추가한다. (값: 'linear', 'ffill', 'bfill', 'spline', 'polynomial', 'pchip', 'akima', 'none')
    - `ChartDataResponse`: 집계된 결과(라벨, 값 배열 등)의 구조를 정의한다.
3.  **데이터 처리 서비스 로직 추가 (`services/data_access.py`)**
    - `get_chart_data()`: 요청된 조건에 따라 DuckDB를 사용하여 데이터를 처리하는 함수를 구현한다.
    - **처리 순서:** (1) `GAPFILL`을 사용해 시간 축을 일정하게 만들고, (2) 사용자가 선택한 보간 방법에 따라 결측치를 채운 뒤, (3) 최종적으로 데이터를 집계하거나 샘플링한다.

### 4.2. 프론트엔드 (React)

1.  **차트 라이브러리 선정 및 설치**
    - 대용량 데이터 처리와 인터랙션에 강점이 있는 **`ECharts for React`** 또는 **`uPlot`** 사용을 권장한다.
2.  **신규 컴포넌트 개발**
    - `ChartPanel.tsx`: ECharts 인스턴스를 생성하고 데이터를 받아 차트를 렌더링하며, Zoom/Pan 이벤트를 처리하는 핵심 컴포넌트.
    - `ChartControls.tsx`: 사용자가 차트 종류, X/Y축 컬럼, **보간 방법** 등을 선택할 수 있는 UI(예: 드롭다운 메뉴)를 추가한다.
3.  **상태 관리 확장 (`state/useDashboardStore.ts`)**
    - 차트 설정(종류, 축, **보간 방법**), 데이터, 로딩/에러 상태를 관리하는 로직을 추가한다.
4.  **API 서비스 함수 추가 (`services/csvService.ts`)**
    - `fetchChartData()`: 백엔드에 차트 데이터를 요청하는 비동기 함수를 추가한다.

## 5. 제안하는 첫 단계

백엔드에 **데이터 집계 API의 기본 버전을 구현**하는 것부터 시작한다. 우선 특정 파일에 대해 고정된 시간 단위(예: 1일)로 데이터를 집계하고, **'보간 안 함' 옵션**을 기본으로 하여 반환하는 엔드포인트를 개발한다. 이후 보간, 동적 파라미터 등을 처리하도록 확장한다.
